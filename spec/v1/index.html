<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Specification</title>

  <style type="text/css">
body {
margin: 0;
padding: 0;
font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
font-size: 16px;
line-height: 1.6;
background: #fafafa;
color: #333;
}
.wrapper {
display: flex;
align-items: flex-start;
}

.mobile-header {
display: none;
background: #fff;
border-bottom: 1px solid #ddd;
padding: 10px 16px;
position: sticky;
top: 0;
z-index: 1000;
}
#menuButton {
font-size: 18px;
padding: 8px 12px;
border: none;
background: #0077cc;
color: #fff;
border-radius: 6px;
cursor: pointer;
}

#sidebar {
width: 260px;
padding: 20px;
background: #ffffff;
border-right: 1px solid #e0e0e0;
height: 100vh;
position: sticky;
top: 0;
overflow-y: auto;
transition: transform 0.3s ease;
}
#sidebar h2 {
font-size: 18px;
margin-top: 0;
}
#sidebar a {
color: #005aa0;
text-decoration: none;
}
#sidebar a:hover {
text-decoration: underline;
}

#content {
flex: 1;
padding: 40px;
max-width: 900px;
margin: 0 auto;
background: #fafafa;
}
h1, h2, h3, h4 {
color: #222;
margin-top: 2.4em;
margin-bottom: 0.6em;
font-weight: 600;
}
h1 {
font-size: 2.2em;
border-bottom: 2px solid #eee;
padding-bottom: 0.3em;
}
h2 {
font-size: 1.8em;
border-bottom: 1px solid #eee;
padding-bottom: 0.2em;
}
h3 { font-size: 1.4em; }
h4 { font-size: 1.2em; }
p { margin: 0.8em 0; }

pre {
background: #2d2d2d;
padding: 16px;
border-radius: 6px;
overflow-x: auto;
}
code {
font-family: SFMono-Regular, Consolas, Menlo, monospace;
font-size: 0.95em;
color: #f8f8f2;
}
p code, li code {
background: #eee;
color: #c7254e;
padding: 2px 4px;
border-radius: 4px;
}

table {
border-collapse: collapse;
margin: 1.5em 0;
width: 100%;
overflow-x: auto;
display: block;
}
th, td {
border: 1px solid #ddd;
padding: 10px;
}
th {
background: #f0f0f0;
font-weight: 600;
}

blockquote {
border-left: 4px solid #ccc;
padding-left: 16px;
color: #666;
margin-left: 0;
}

@media (max-width: 900px) {
.wrapper {
flex-direction: column;
}
.mobile-header {
display: block;
}
#sidebar {
position: fixed;
top: 0;
left: 0;
height: 100%;
transform: translateX(-100%);
z-index: 999;
box-shadow: 2px 0 12px rgba(0,0,0,0.1);
}
#sidebar.open {
transform: translateX(0);
}
#content {
padding: 20px;
margin: 0;
max-width: 100%;
}
h1 {
font-size: 1.8em;
}
h2 {
font-size: 1.4em;
}
pre {
font-size: 0.85em;
}
}</style>

  <style>
pre code { white-space: pre-wrap; }
</style>
</head>

<body>

<div class="mobile-header">
  <button id="menuButton">☰ Menu</button>
</div>

<div class="wrapper">

  <!-- Left sidebar TOC -->
  <nav id="sidebar">
    <h2>Contents</h2>
    <ul>
    <li><a href="#didme-method-specification-v1" id="toc-didme-method-specification-v1">did:me Method Specification
    (v1)</a>
    <ul>
    <li><a href="#introduction" id="toc-introduction">1.
    Introduction</a></li>
    <li><a href="#did-format" id="toc-did-format">2. DID Format</a>
    <ul>
    <li><a href="#did-syntax" id="toc-did-syntax">2.1 DID
    Syntax</a></li>
    <li><a href="#allowed-characters" id="toc-allowed-characters">2.2
    Allowed characters</a></li>
    <li><a href="#length" id="toc-length">2.3 Length</a></li>
    <li><a href="#example" id="toc-example">2.4 Example</a></li>
    </ul></li>
    <li><a href="#did-resolution" id="toc-did-resolution">3. DID
    Resolution</a>
    <ul>
    <li><a href="#optional-directory-based-resolution" id="toc-optional-directory-based-resolution">3.1 Optional
    Directory-Based Resolution</a></li>
    <li><a href="#http-status-codes" id="toc-http-status-codes">3.2 HTTP
    Status Codes</a></li>
    </ul></li>
    <li><a href="#data-model-overview" id="toc-data-model-overview">4.
    Data Model Overview</a>
    <ul>
    <li><a href="#method-specific-extension-properties" id="toc-method-specific-extension-properties">4.1 Method-Specific
    Extension Properties</a></li>
    <li><a href="#encoding-preferences" id="toc-encoding-preferences">4.2 Encoding Preferences</a></li>
    <li><a href="#protocol-buffers" id="toc-protocol-buffers">4.3
    Protocol buffers</a></li>
    </ul></li>
    <li><a href="#core-object" id="toc-core-object">5. Core Object</a>
    <ul>
    <li><a href="#purpose" id="toc-purpose">5.1 Purpose</a></li>
    <li><a href="#core-schema-conceptual" id="toc-core-schema-conceptual">5.2 Core Schema
    (Conceptual)</a></li>
    <li><a href="#corekey-schema" id="toc-corekey-schema">5.3 CoreKey
    Schema</a></li>
    <li><a href="#coreupdatepolicy" id="toc-coreupdatepolicy">5.4
    CoreUpdatePolicy</a></li>
    <li><a href="#coreservice-schema" id="toc-coreservice-schema">5.5
    CoreService Schema</a></li>
    <li><a href="#canonical-cbor-encoding" id="toc-canonical-cbor-encoding">5.6 Canonical CBOR
    Encoding</a></li>
    <li><a href="#cid-derivation" id="toc-cid-derivation">5.7 CID
    Derivation</a></li>
    <li><a href="#payment-and-crypto-address-services" id="toc-payment-and-crypto-address-services">5.8 Payment and Crypto
    Address Services</a></li>
    <li><a href="#eu-digital-identity-wallet-interoperability" id="toc-eu-digital-identity-wallet-interoperability">5.9 EU Digital
    Identity Wallet Interoperability</a>
    <ul>
    <li><a href="#eudi-wallet-subject-compatibility" id="toc-eudi-wallet-subject-compatibility">5.9.1 EUDI Wallet Subject
    Compatibility</a></li>
    <li><a href="#oidc4vci-and-oidc4vp-service-endpoints" id="toc-oidc4vci-and-oidc4vp-service-endpoints">5.9.2 OIDC4VCI and
    OIDC4VP Service Endpoints</a></li>
    <li><a href="#optional-service-type-for-eudi-integration" id="toc-optional-service-type-for-eudi-integration">5.9.3 Optional
    Service Type for EUDI Integration</a></li>
    </ul></li>
    <li><a href="#wallet-binding-and-domain-verification" id="toc-wallet-binding-and-domain-verification">5.10 Wallet Binding
    and Domain Verification</a></li>
    </ul></li>
    <li><a href="#data-integrity-proofs-optional-p-256-anchor" id="toc-data-integrity-proofs-optional-p-256-anchor">6. Data
    Integrity Proofs (Optional P-256 Anchor)</a>
    <ul>
    <li><a href="#purpose-and-motivation" id="toc-purpose-and-motivation">6.1 Purpose and Motivation</a></li>
    <li><a href="#proof-object-schema" id="toc-proof-object-schema">6.2
    Proof Object Schema</a></li>
    <li><a href="#cryptosuite-es256-jws-cid-2025" id="toc-cryptosuite-es256-jws-cid-2025">6.3 Cryptosuite:
    es256-jws-cid-2025</a></li>
    <li><a href="#ecdsa-s-value-canonicality" id="toc-ecdsa-s-value-canonicality">6.4 ECDSA S-Value
    Canonicality</a></li>
    <li><a href="#interoperability-and-usage-notes" id="toc-interoperability-and-usage-notes">6.5 Interoperability and
    Usage Notes</a></li>
    </ul></li>
    <li><a href="#signatures-and-attestations" id="toc-signatures-and-attestations">7. Signatures and
    Attestations</a>
    <ul>
    <li><a href="#core-signature" id="toc-core-signature">7.1 Core
    Signature</a></li>
    <li><a href="#additional-signatures" id="toc-additional-signatures">7.2 Additional Signatures</a></li>
    </ul></li>
    <li><a href="#operations" id="toc-operations">8. Operations</a>
    <ul>
    <li><a href="#create" id="toc-create">8.1 Create</a></li>
    <li><a href="#update" id="toc-update">8.2 Update</a>
    <ul>
    <li><a href="#multiple-controllers" id="toc-multiple-controllers">8.2.1 Multiple Controllers</a></li>
    </ul></li>
    <li><a href="#deactivate" id="toc-deactivate">8.3
    Deactivate</a></li>
    </ul></li>
    <li><a href="#did-document-projection" id="toc-did-document-projection">9. DID Document Projection</a>
    <ul>
    <li><a href="#field-mapping-from-core" id="toc-field-mapping-from-core">9.1 Field Mapping from
    Core</a></li>
    <li><a href="#method-specific-extensions-non-core-metadata" id="toc-method-specific-extensions-non-core-metadata">9.2
    Method-Specific Extensions (Non-Core Metadata)</a>
    <ul>
    <li><a href="#domain-verification-objects" id="toc-domain-verification-objects">9.3 Domain Verification
    Objects</a></li>
    </ul></li>
    <li><a href="#requirements" id="toc-requirements">9.4
    Requirements</a></li>
    </ul></li>
    <li><a href="#json-ld-context" id="toc-json-ld-context">10. JSON-LD
    Context</a>
    <ul>
    <li><a href="#alsoknownas-optional-correlation-identifiers" id="toc-alsoknownas-optional-correlation-identifiers">10.1
    alsoKnownAs (Optional Correlation Identifiers)</a></li>
    <li><a href="#hardware-bound-and-biometric-protected" id="toc-hardware-bound-and-biometric-protected">10.2 Hardware Bound
    and Biometric Protected</a></li>
    <li><a href="#user-verification-method" id="toc-user-verification-method">10.3 User Verification
    Method</a></li>
    <li><a href="#device-and-model" id="toc-device-and-model">10.4
    Device and Model</a></li>
    </ul></li>
    <li><a href="#security-considerations" id="toc-security-considerations">11. Security
    Considerations</a></li>
    <li><a href="#decentralization-and-federation" id="toc-decentralization-and-federation">12. Decentralization and
    Federation</a></li>
    <li><a href="#illustrative-didme-json-member-order-non-normative" id="toc-illustrative-didme-json-member-order-non-normative">13.
    Illustrative did:me JSON member order (non-normative)</a></li>
    <li><a href="#default-profile-requirements-matrix-didme-v1" id="toc-default-profile-requirements-matrix-didme-v1">14. Default
    Profile Requirements Matrix (did:me v1)</a>
    <ul>
    <li><a href="#did-document-field-matrix" id="toc-did-document-field-matrix">14.1 DID Document Field
    Matrix</a></li>
    <li><a href="#null-vs-omission-rules-summary" id="toc-null-vs-omission-rules-summary">14.2 Null vs Omission Rules
    Summary</a></li>
    <li><a href="#required-arrays-non-null" id="toc-required-arrays-non-null">14.3 Required Arrays
    (non-null)</a></li>
    <li><a href="#optional-arrays" id="toc-optional-arrays">14.4
    Optional Arrays</a></li>
    </ul></li>
    <li><a href="#did-document-relationship-definitions" id="toc-did-document-relationship-definitions">DID Document
    Relationship Definitions</a>
    <ul>
    <li><a href="#verificationmethod" id="toc-verificationmethod">verificationMethod</a></li>
    <li><a href="#authentication" id="toc-authentication">authentication</a></li>
    <li><a href="#assertionmethod" id="toc-assertionmethod">assertionMethod</a></li>
    <li><a href="#keyagreement" id="toc-keyagreement">keyAgreement</a></li>
    <li><a href="#capabilityinvocation" id="toc-capabilityinvocation">capabilityInvocation</a></li>
    <li><a href="#attestations" id="toc-attestations">attestations</a></li>
    <li><a href="#proof" id="toc-proof">proof</a></li>
    </ul></li>
    <li><a href="#conformance-test-vectors-informative" id="toc-conformance-test-vectors-informative">15. Conformance Test
    Vectors (Informative)</a>
    <ul>
    <li><a href="#context-canonical-prefix" id="toc-context-canonical-prefix">15.1 <span class="citation" data-cites="context">@context</span> Canonical Prefix</a>
    <ul>
    <li><a href="#valid" id="toc-valid">15.1.1 Valid</a></li>
    <li><a href="#invalid" id="toc-invalid">15.1.2 Invalid</a></li>
    <li><a href="#invalid-term-redefinition-in-additional-context" id="toc-invalid-term-redefinition-in-additional-context">15.1.3
    Invalid (Term Redefinition in Additional Context)</a></li>
    </ul></li>
    <li><a href="#corecbor-and-currentcore-consistency" id="toc-corecbor-and-currentcore-consistency">15.2
    <code>coreCbor</code> and <code>currentCore</code> Consistency</a>
    <ul>
    <li><a href="#valid-1" id="toc-valid-1">15.2.1 Valid</a></li>
    <li><a href="#invalid-1" id="toc-invalid-1">15.2.2 Invalid</a></li>
    </ul></li>
    <li><a href="#sequence-prev-and-keyhistory" id="toc-sequence-prev-and-keyhistory">15.3 <code>sequence</code>,
    <code>prev</code>, and <code>keyHistory</code></a>
    <ul>
    <li><a href="#valid-genesis" id="toc-valid-genesis">15.3.1 Valid
    Genesis</a></li>
    <li><a href="#invalid-non-genesis" id="toc-invalid-non-genesis">15.3.2 Invalid Non-Genesis</a></li>
    </ul></li>
    <li><a href="#core-attestation-validation" id="toc-core-attestation-validation">15.4 Core Attestation
    Validation</a>
    <ul>
    <li><a href="#valid-2" id="toc-valid-2">15.4.1 Valid</a></li>
    <li><a href="#invalid-2" id="toc-invalid-2">15.4.2 Invalid</a></li>
    </ul></li>
    <li><a href="#data-integrity-proof-behavior" id="toc-data-integrity-proof-behavior">15.5 Data Integrity Proof
    Behavior</a>
    <ul>
    <li><a href="#valid-supported-suite" id="toc-valid-supported-suite">15.5.1 Valid (Supported
    Suite)</a></li>
    <li><a href="#unsupported-suite-handling" id="toc-unsupported-suite-handling">15.5.2 Unsupported Suite
    Handling</a></li>
    </ul></li>
    </ul></li>
    </ul></li>
    </ul>
  </nav>

  <main id="content">
    <h1 id="didme-method-specification-v1">did:me Method Specification
    (v1)</h1>
    <p><strong>Status:</strong> Beta<br />
    <strong>Specification URI:</strong> https://did-me.org/spec/v1/
    <strong>JSON-LD Context:</strong>
    https://did-me.org/ns/did-me/v1</p>
    <hr />
    <h2 id="introduction">1. Introduction</h2>
    <p><code>did:me</code> is a DID method designed for:</p>
    <ul>
    <li>Stable identifiers for individuals, pseudonymous personas,
    organizations, and groups</li>
    <li>Identifiers <strong>not derived from cryptographic
    keys</strong>, ensuring DID stability across rekeying</li>
    <li>CID-versioned core snapshots that define canonical DID
    state<br />
    </li>
    <li>Classical and post-quantum verification methods</li>
    <li>Compatibility with EU Digital Identity Wallets, OpenID4VCI /
    OpenID4VP, and ZK-proof circuits</li>
    </ul>
    <p>The authoritative DID state is represented by a <strong>core
    object</strong>, encoded using canonical DAG-CBOR, hashed to a
    <strong>CID</strong>, and signed by the DID controller. The public
    DID Document is a JSON projection derived from this signed core.</p>
    <p><code>did:me</code> identifiers are fundamentally self-hosted
    DIDs whose authoritative state lives on the controller’s wallet,
    device, or agent. No central registry is required for validity or
    resolution. Decentralization is enabled by the method’s
    cryptographic update structure, including:</p>
    <ul>
    <li>Monotonic <code>sequence</code> counters for update
    ordering<br />
    </li>
    <li><code>prev</code> links referencing the CID of the previous
    core</li>
    <li>A verifiable, tamper-evident chain of signed core snapshots</li>
    </ul>
    <hr />
    <h2 id="did-format">2. DID Format</h2>
    <p><code>did:me</code> identifiers are <strong>not derived from keys
    or core CIDs</strong>.<br />
    This ensures DID stability even as keys rotate or services
    change.</p>
    <h3 id="did-syntax">2.1 DID Syntax</h3>
    <p>A <code>did:me</code> identifier MUST conform to:</p>
    <pre><code>did:me:&lt;identifier&gt;</code></pre>
    <p>Where <code>&lt;identifier&gt;</code> is the <strong>full
    Bech32-encoded string</strong>, including: - the HRP
    <code>&quot;me&quot;</code><br />
    - the separator <code>&quot;1&quot;</code><br />
    - the 5-bit data payload<br />
    - the Bech32 checksum</p>
    <p>Identifiers are generated by:</p>
    <ol type="1">
    <li>Generating <strong>16 bytes (128 bits)</strong> of
    cryptographically secure entropy<br />
    </li>
    <li>Converting the entropy into <strong>5-bit groups</strong> (8→5
    conversion, padded)<br />
    </li>
    <li>Encoding the result via <strong>Bech32</strong> with HRP
    <code>&quot;me&quot;</code></li>
    </ol>
    <p><strong>Formal representation:</strong></p>
    <pre><code>identifier = Bech32.encode(hrp=&quot;me&quot;, data=convertBits(entropy[16], 8→5))</code></pre>
    <p>The checksum included in the Bech32 output MUST be preserved, as
    it provides error-detection and guards against accidental
    corruption.</p>
    <h3 id="allowed-characters">2.2 Allowed characters</h3>
    <p>The data portion of the Bech32 identifier (after “me1”) MUST
    match Bech32’s lowercase character set:</p>
    <pre><code>^[023456789acdefghjklmnpqrstuvwxyz]+$</code></pre>
    <p>(Excludes: <code>1</code>, <code>b</code>, <code>i</code>,
    <code>o</code>.)</p>
    <h3 id="length">2.3 Length</h3>
    <p>Given 16 bytes of entropy: - 16 bytes × 8 bits = 128 bits -
    Converted to ~26 five-bit groups - Bech32 encoding produces ~26–35
    characters, including checksum</p>
    <h3 id="example">2.4 Example</h3>
    <pre><code>did:me:me1q90w7wd0qpsl6rh6tsg4y0e0a60p3f60g</code></pre>
    <hr />
    <h2 id="did-resolution">3. DID Resolution</h2>
    <h3 id="optional-directory-based-resolution">3.1 Optional
    Directory-Based Resolution</h3>
    <p>Controllers MAY publish their DID Document to one or more public
    directories (e.g., reallyme.directory). If published, a DID Document
    can be retrieved via:</p>
    <pre><code>GET https://reallyme.directory/dids/&lt;id&gt;</code></pre>
    <p>This endpoint is optional and not required for DID validity or
    resolution. Local resolvers MAY reconstruct DID state using only the
    signed core chain.</p>
    <h3 id="http-status-codes">3.2 HTTP Status Codes</h3>
    <ul>
    <li><code>200 OK</code> — DID Document returned<br />
    </li>
    <li><code>404 Not Found</code> — DID not registered</li>
    </ul>
    <hr />
    <h2 id="data-model-overview">4. Data Model Overview</h2>
    <p>A <code>did:me</code> DID Document is a standard DID Document
    projected from a signed core object and: - Uses
    <code>verificationMethod</code>, <code>authentication</code>,
    <code>assertionMethod</code>, <code>capabilityInvocation</code>,
    <code>keyAgreement</code>, and <code>service</code> as defined in
    DID Core. - Adds the following method-specific fields: -
    <code>sequence</code> — monotonic per-DID update counter<br />
    - <code>prev</code> — CID of the previous core (or
    <code>null</code>)<br />
    - <code>currentCore</code> — CID of the current DAG-CBOR core
    object<br />
    - <code>keyHistory</code> — ordered list of prior core CIDs -
    <code>updatePolicy</code> — rules defining which verification
    methods may authorize updates<br />
    - <code>attestations</code> — signatures over the core object by the
    DID controller<br />
    - <code>proof</code> — optional Data Integrity Proof over
    <code>currentCore</code><br />
    - <code>domainVerification</code> — optional DNS/HTTP binding the
    DID to a domain</p>
    <h3 id="method-specific-extension-properties">4.1 Method-Specific
    Extension Properties</h3>
    <p><code>did:me</code> supports optional, method-specific properties
    that extend the base DID Document data model. These properties are
    defined in the did:me JSON-LD context:</p>
    <p>https://did-me.org/ns/did-me/v1</p>
    <p>The context defines terms such as: - currentCore - keyHistory -
    attestations - updatePolicy - domainVerification - and additional
    optional metadata fields (e.g., hardwareBound, biometricProtected,
    deviceModel)</p>
    <p>All method-specific terms: - MAY appear in a DID Document - MUST
    NOT affect the validity of the core snapshot or signature - MUST be
    ignored by processors that do not understand them, per DID Core
    rules - MUST NOT change the canonical core object unless explicitly
    listed in the core schema</p>
    <p>These extensions allow did:me to support richer metadata while
    preserving DID Core compatibility and forward extensibility.</p>
    <h3 id="encoding-preferences">4.2 Encoding Preferences</h3>
    <p>Did:me should use base64url encoding for keys.</p>
    <h3 id="protocol-buffers">4.3 Protocol buffers</h3>
    <p>Due to the size of post-quantum keys, did:me documents MAY use
    Protocol Buffers as an optional (and preferred) transport/storage
    encoding.</p>
    <p>The canonical authoritative state is always the signed canonical
    DAG-CBOR core: - CID derivation MUST be performed from canonical
    DAG-CBOR core bytes - authoritative signature verification MUST be
    performed over canonical DAG-CBOR core bytes</p>
    <p>The DID Document JSON is a projection output derived from the
    core. Protocol Buffers bytes MUST NOT be used for CID derivation or
    authoritative signature verification.</p>
    <hr />
    <h2 id="core-object">5. Core Object</h2>
    <h3 id="purpose">5.1 Purpose</h3>
    <p>The <strong>core object</strong> is the canonical representation
    of DID state. It is:</p>
    <ul>
    <li>encoded using <strong>canonical DAG-CBOR</strong></li>
    <li>hashed to a <strong>CID</strong> (CIDv1, SHA-256, base32)</li>
    <li><strong>signed</strong> by the DID controller</li>
    <li>used to derive the public JSON DID Document (“projection”)</li>
    </ul>
    <p>Although the DID string never changes, all mutable cryptographic
    state is reflected through successive, signed core snapshots.</p>
    <p><code>currentCore</code> contains the CID of the latest snapshot.
    <code>keyHistory</code> contains only the CIDs of prior core
    snapshots, in ascending sequence order. <code>prev</code> references
    the immediately preceding core CID and enforces canonical update
    ordering.</p>
    <p><code>prev</code> enables: - rollback prevention (reject older
    snapshots) - replay protection (reject repeated snapshots) - fork
    detection (reject alternative update branches)</p>
    <p>This design provides: - deterministic state integrity -
    tamper-evident version history - key rotation without changing the
    DID - future support for decentralized or mirrored resolvers</p>
    <p>The <code>keyHistory</code> array MUST contain only the CIDs of
    all prior core snapshots and MUST NOT include the
    <code>currentCore</code> CID. The CIDs in <code>keyHistory</code>
    MUST be ordered in strict ascending sequence order, representing the
    canonical update history from the first snapshot to the most recent
    prior snapshot.</p>
    <h3 id="core-schema-conceptual">5.2 Core Schema (Conceptual)</h3>
    <pre><code>Core = {
  id: string,                       // &quot;did:me:&lt;id&gt;&quot;
  sequence: uint64,                 // monotonic update counter.  This always starts at 1.
  prev: CID | null,                 // CID of previous core.   If null, then prev is omitted.
  controller: string | string[],    // one or more controllers
  controllerKeys: [CoreKey],        // declared keys
  authenticationKeys: [string],     // references into controllerKeys
  assertionKeys: [string],
  keyAgreementKeys: [string],
  services: [CoreService],          // service endpoints
  updatePolicy: CoreUpdatePolicy,   // defines which verification methods may authorize updates
}</code></pre>
    <p>This schema represents exactly the content protected by the
    signature. Anything not included here (e.g., proof,
    domainVerification) is not part of the core and does not affect DID
    validity.</p>
    <p>A did:me DID MAY have one or more controllers. If only one
    controller is present, it is typically the DID subject itself.</p>
    <h3 id="corekey-schema">5.3 CoreKey Schema</h3>
    <p>All of the following are required values:</p>
    <pre><code>CoreKey = {
  id: string,                     // e.g., &quot;#ed25519&quot;
  type: string,                   // e.g., &quot;Multikey&quot;, &quot;MLDSA87Key2024&quot;
  algorithm: string,              // e.g., &quot;ES256&quot;, &quot;Ed25519&quot;, &quot;ML-DSA-87&quot;
  publicKeyMultibase: string
}</code></pre>
    <p>Keys listed here define: - which verification methods exist -
    which methods can sign updates (via updatePolicy) - which methods
    serve authentication, assertion, invocation, or key agreement</p>
    <p>All key relationship references (authenticationKeys,
    assertionKeys, keyAgreementKeys, and allowedVerificationMethods in
    updatePolicy) MUST refer to a CoreKey.id present in controllerKeys.
    Section 14 defines a stricter, normative default profile for public
    did:me v1 interoperability; those profile requirements may constrain
    this base model further.</p>
    <h3 id="coreupdatepolicy">5.4 CoreUpdatePolicy</h3>
    <p>The update policy is part of the canonical core object and
    defines which verification methods are authorized to sign core
    updates.</p>
    <pre><code>CoreUpdatePolicy = {
  allowedVerificationMethods: [string]   // references into controllerKeys by id.  These strings MUST match a CoreKey.id.
}</code></pre>
    <h3 id="coreservice-schema">5.5 CoreService Schema</h3>
    <pre><code>CoreService = {
  id: string,                     // &quot;#hub&quot;, &quot;#openid&quot;, &quot;#wallet&quot;
  type: string,                   // DID Core service type or did:me extension
  serviceEndpoint: any,           // URI or structured JSON
  version?: string
}</code></pre>
    <p>Service endpoints are part of the core snapshot and therefore
    immutable within each version.</p>
    <h3 id="canonical-cbor-encoding">5.6 Canonical CBOR Encoding</h3>
    <p>The core object MUST be encoded using canonical CBOR: - Map keys
    sorted lexicographically by UTF-8 bytes - Only definite-length
    arrays/maps - UTF-8 text keys - No undefined or extraneous fields -
    Deterministic encoding per RFC 8949 / DAG-CBOR restrictions</p>
    <p>This ensures: - identical encoding across languages - identical
    CIDs across implementations - provable state integrity</p>
    <p>Implementations MUST reject cores containing indefinite-length
    items or map keys not in strictly sorted order.</p>
    <h3 id="cid-derivation">5.7 CID Derivation</h3>
    <p>The CID is computed as follows:</p>
    <ul>
    <li><strong>Codec</strong>: <code>dag-cbor</code><br />
    </li>
    <li><strong>Multihash</strong>: <code>SHA-256</code><br />
    </li>
    <li><strong>CID version</strong>: v1</li>
    <li><strong>Multibase</strong>: base32 (lowercase)</li>
    </ul>
    <p>This CID is published as: <sub></sub>~ “currentCore”: “<cid>”
    <sub></sub>~</p>
    <p>and used to verify signatures over the core.</p>
    <h3 id="payment-and-crypto-address-services">5.8 Payment and Crypto
    Address Services</h3>
    <p>did:me supports chain-agnostic crypto payment addresses through
    standard DID Core service entries. These addresses are
    non-authoritative metadata and are not part of the core update
    authorization model unless the corresponding public keys also appear
    in controllerKeys.</p>
    <p>A DID MAY include one or more payment-related services such as: •
    Bitcoin (bech32) • Ethereum and EVM chains (0x-prefixed addresses) •
    Solana (base58) • Avalanche (X-Chain, C-Chain, or P-Chain formats) •
    Any other blockchain or digital payment network</p>
    <p>Payment addresses MUST be expressed as a structured JSON
    serviceEndpoint object, for example:</p>
    <pre><code>{
  &quot;id&quot;: &quot;#wallet&quot;,
  &quot;type&quot;: &quot;PaymentService&quot;,
  &quot;serviceEndpoint&quot;: {
    &quot;btc&quot;: &quot;bc1q...&quot;,
    &quot;eth&quot;: &quot;0x1234...&quot;,
    &quot;sol&quot;: &quot;So1111...&quot;,
    &quot;avax&quot;: &quot;0xabc...&quot;
  }
}</code></pre>
    <h3 id="eu-digital-identity-wallet-interoperability">5.9 EU Digital
    Identity Wallet Interoperability</h3>
    <p>did:me is designed to interoperate cleanly with the European
    Digital Identity Wallet (EUDI Wallet) architecture, including PID,
    ARF, and EBSI profiles. DID Documents MAY include service endpoints
    and proof formats that support credential issuance, presentation,
    and trust-chain interoperability.</p>
    <h4 id="eudi-wallet-subject-compatibility">5.9.1 EUDI Wallet Subject
    Compatibility</h4>
    <p>did:me identifiers: • are stable, non-key-derived identifiers •
    support rekeying without subject identifier changes • are fully
    compatible as subject_id values in PID / ARF data models • remain
    resolvable even when controller cryptographic material rotates</p>
    <h4 id="oidc4vci-and-oidc4vp-service-endpoints">5.9.2 OIDC4VCI and
    OIDC4VP Service Endpoints</h4>
    <p>did:me supports EUDI wallet credential flows via standard DID
    Core service entries:</p>
    <pre><code>{
  &quot;id&quot;: &quot;#openid-credential-offer&quot;,
  &quot;type&quot;: &quot;OpenID4VCI&quot;,
  &quot;serviceEndpoint&quot;: &quot;&lt;issuer-endpoint&gt;&quot;
}

{
  &quot;id&quot;: &quot;#oid4vp&quot;,
  &quot;type&quot;: &quot;OpenID4VP&quot;,
  &quot;serviceEndpoint&quot;: &quot;&lt;presentation-endpoint&gt;&quot;
}</code></pre>
    <p>Resolvers MAY treat these endpoints as wallet-compatible
    credential interfaces.</p>
    <h4 id="optional-service-type-for-eudi-integration">5.9.3 Optional
    Service Type for EUDI Integration</h4>
    <p>Implementations MAY define a dedicated service entry for EUDI
    wallet interactions:</p>
    <pre><code>{
  &quot;id&quot;: &quot;#eudi&quot;,
  &quot;type&quot;: &quot;EudiCredentialService&quot;,
  &quot;serviceEndpoint&quot;: &quot;&lt;eudi-service-url&gt;&quot;
}</code></pre>
    <p>This is functionally equivalent to using OpenID4VCI and
    OpenID4VP, but provides clearer semantic typing for wallets that
    recognize EUDI-specific services.</p>
    <h3 id="wallet-binding-and-domain-verification">5.10 Wallet Binding
    and Domain Verification</h3>
    <p>DID Documents MAY include domainVerification entries used for: •
    binding a DID to a legally recognized domain • proving issuer
    authenticity • supporting EUDI trust chain requirements</p>
    <p>These domain bindings are optional metadata and do not alter core
    state.</p>
    <hr />
    <h2 id="data-integrity-proofs-optional-p-256-anchor">6. Data
    Integrity Proofs (Optional P-256 Anchor)</h2>
    <h3 id="purpose-and-motivation">6.1 Purpose and Motivation</h3>
    <p><code>did:me</code> supports optional
    <code>DataIntegrityProof</code> objects using ES256 (P-256).</p>
    <p>These proofs provide a classical-cryptography signature anchor
    suitable for:</p>
    <ul>
    <li>EU Digital Identity Wallet trust infrastructure</li>
    <li>zero-knowledge proof circuits</li>
    <li>verifiers that require standardized P-256 semantics</li>
    <li>environments that cannot process canonical DAG-CBOR</li>
    </ul>
    <p>These proofs are non-authoritative: the authoritative
    cryptographic rail is the signature over the canonical DAG-CBOR core
    snapshot.</p>
    <p>DI proofs: - MAY appear in a DID Document - MUST NOT influence
    update authorization or determine DID validity</p>
    <h3 id="proof-object-schema">6.2 Proof Object Schema</h3>
    <p>A did:me DataIntegrityProof using the
    <code>es256-jws-cid-2025</code> cryptosuite appears as follows:</p>
    <pre><code>&quot;proof&quot;: {
  &quot;type&quot;: &quot;DataIntegrityProof&quot;,
  &quot;cryptosuite&quot;: &quot;es256-jws-cid-2025&quot;,
  &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
  &quot;verificationMethod&quot;: &quot;#p256&quot;,
  &quot;created&quot;: &quot;&lt;ISO8601Z&gt;&quot;,
  &quot;jws&quot;: &quot;&lt;compact-jws-with-currentCore-as-payload&gt;&quot;
}</code></pre>
    <p><code>es256-jws-cid-2025</code> is a did:me-defined custom Data
    Integrity cryptosuite profile. Implementations MUST apply the
    verification algorithm defined in this specification for this
    cryptosuite value.</p>
    <p>The proof MUST:</p>
    <ul>
    <li>sign the UTF-8 byte sequence of the currentCore CID string</li>
    <li>NOT sign or canonicalize any other part of the DID Document</li>
    <li>use a verificationMethod listed in assertionMethod</li>
    </ul>
    <h3 id="cryptosuite-es256-jws-cid-2025">6.3 Cryptosuite:
    es256-jws-cid-2025</h3>
    <p>The cryptosuite identifier:</p>
    <pre><code>&quot;cryptosuite&quot;: &quot;es256-jws-cid-2025&quot;</code></pre>
    <p>The es256-jws-cid-2025 suite defines a compact ES256 JWS
    signature over the currentCore CID string. This cryptosuite is a
    did:me custom profile and is not required to be supported by generic
    Data Integrity processors unless they implement this suite
    definition.</p>
    <p><strong>Components</strong>:</p>
    <ul>
    <li><strong>Signature type</strong>: ECDSA secp256r1 (P-256)</li>
    <li><strong>Representation</strong>: compact JWS
    (header.payload.signature)</li>
    <li><strong>Protected header</strong>: The protected header MUST
    contain exactly the single member {“alg”:“ES256”}.</li>
    <li><strong>Payload</strong>: the UTF-8 byte sequence of the
    currentCore CID string</li>
    <li><strong>Signing input</strong>: BASE64URL(header) + “.” +
    BASE64URL(payload)</li>
    <li><strong>Signature format</strong>: JWS ES256 signature bytes in
    fixed-length <code>R || S</code> form (64 bytes total,
    base64url-encoded in the JWS signature segment)</li>
    </ul>
    <p><strong>Verification Steps</strong>: 1. Parse the compact JWS
    into header, payload, signature. 2. Confirm header.alg === “ES256”.
    3. Decode payload and confirm it equals currentCore. 4. Recompute
    signingInput. 5. Verify ECDSA P-256 over SHA-256(signingInput) using
    the referenced P-256 key.</p>
    <p>This proof MUST NOT be used to authorize DID updates. If a
    verifier does not support <code>es256-jws-cid-2025</code>, it MUST
    treat this proof as unsupported and MUST NOT treat it as valid.</p>
    <h3 id="ecdsa-s-value-canonicality">6.4 ECDSA S-Value
    Canonicality</h3>
    <p>ES256 signatures MAY use either the “low-S” or “high-S” form.
    Both are cryptographically valid and MUST be accepted.</p>
    <p>Implementations: - MAY normalize to low-S (s ≤ n/2) - MUST NOT
    reject high-S signatures - MAY apply normalization internally (s :=
    min(s, n − s))</p>
    <p>This rule ensures full interoperability across platforms such as
    Secure Enclave, WebCrypto, and noble-curves.</p>
    <h3 id="interoperability-and-usage-notes">6.5 Interoperability and
    Usage Notes</h3>
    <ul>
    <li>DI proofs are optional metadata and do not affect DID validity
    or update logic.</li>
    <li>Resolvers MUST ignore DI proofs when determining the
    authoritative core chain.</li>
    <li>Relying parties MAY use DI proofs for assurance or
    trust-framework requirements.</li>
    <li>DI proofs MAY be safely added, omitted, or mirrored without
    affecting core state.</li>
    <li>The suite is designed to interoperate cleanly with EUDI Wallets,
    OpenID4VCI/VP, and ZK-proof circuits.</li>
    </ul>
    <hr />
    <h2 id="signatures-and-attestations">7. Signatures and
    Attestations</h2>
    <h3 id="core-signature">7.1 Core Signature</h3>
    <p>Each core snapshot MUST be signed by the DID controller using one
    of the verification methods listed in:</p>
    <pre><code>updatePolicy.allowedVerificationMethods</code></pre>
    <p>The signature covers the <strong>raw canonical DAG-CBOR
    bytes</strong> of the core object.</p>
    <p>These signatures are the authoritative root of trust for did:me
    and determine: - whether an update is valid - whether rollback,
    replay, or fork attempts are rejected - whether the currentCore CID
    matches its signed content</p>
    <p>Core signatures appear in:</p>
    <pre><code>&quot;attestations&quot;: [
  {
    &quot;alg&quot;: &quot;ML-DSA-87&quot;,
    &quot;vm&quot;: &quot;#mldsa87-root&quot;,
    &quot;sig&quot;: &quot;&lt;base64url(signature-over-core-cbor)&gt;&quot;
  }
]</code></pre>
    <p>Multiple signatures MAY be present (e.g., Ed25519 and ML-DSA-87)
    to support multi-suite cryptography. For
    <code>attestations.sig</code>, implementations MUST use
    base64url-encoded signature bytes.</p>
    <h3 id="additional-signatures">7.2 Additional Signatures</h3>
    <p>A DID Document MAY include an optional W3C DataIntegrityProof
    using ES256 (P-256). This proof is not authoritative for update
    validation. See Section 6 for the full definition of the
    DataIntegrityProof and the es256-jws-cid-2025 cryptosuite.</p>
    <hr />
    <h2 id="operations">8. Operations</h2>
    <h3 id="create">8.1 Create</h3>
    <p>A new did:me identifier starts with:</p>
    <pre><code>sequence = 1
prev = null</code></pre>
    <p>Creation steps:</p>
    <ol type="1">
    <li>Construct the initial core object</li>
    <li>Encode the core using canonical DAG-CBOR</li>
    <li>Compute currentCore as CIDv1 (dag-cbor, sha2-256)</li>
    <li>Sign the core bytes using an allowed verification method</li>
    <li>Publish the resulting DID Document at the registry endpoint</li>
    </ol>
    <h3 id="update">8.2 Update</h3>
    <p>To update a DID, the registry MUST enforce all of the
    following:</p>
    <pre><code>new.id == old.id
new.sequence == old.sequence + 1
new.prev == old.currentCore
signature(new-core-cbor) verifies under new.updatePolicy.allowedVerificationMethods</code></pre>
    <p>If any check fails, the update MUST be rejected.</p>
    <p>A successful update produces: - a new core snapshot - a new
    currentCore CID - an appended entry in keyHistory - an updated DID
    Document projection</p>
    <h4 id="multiple-controllers">8.2.1 Multiple Controllers</h4>
    <p>A did:me DID MAY list one or more controllers.</p>
    <p>An update is valid if and only if its signature verifies under a
    verification method that:</p>
    <ol type="1">
    <li>is listed in updatePolicy.allowedVerificationMethods, and</li>
    <li>belongs to at least one controller.</li>
    </ol>
    <p>Any single such verification method is sufficient.</p>
    <h3 id="deactivate">8.3 Deactivate</h3>
    <p>To deactivate: - Publish a DID Document with completely empty
    verification relationships (e.g., empty verificationMethod,
    authentication, assertionMethod, and capabilityInvocation arrays). -
    Include a valid core signature from the controller or authorized
    recovery key.</p>
    <p>After deactivation: - The resolver returns 404 Not Found for the
    DID. - A stored deactivated DID Document MAY still be published in a
    separate archival namespace for audit or compliance, but does not
    participate in resolution.</p>
    <hr />
    <h2 id="did-document-projection">9. DID Document Projection</h2>
    <p>The DID Document is a JSON projection derived from the signed
    core. Validation MUST be performed against the core and its
    signatures, not the DID Document.</p>
    <h3 id="field-mapping-from-core">9.1 Field Mapping from Core</h3>
    <p>The following DID Document fields MUST be derived directly from
    the core: - <code>id</code> → core.id - <code>controller</code> →
    core.controller - <code>sequence</code> → core.sequence -
    <code>prev</code> → core.prev - <code>currentCore</code> → CID of
    the canonical DAG-CBOR core snapshot - <code>coreCbor</code> →
    base64url-encoded canonical DAG-CBOR bytes of the current core
    snapshot - <code>verificationMethod</code> → derived from
    core.controllerKeys - <code>authentication</code> → derived from
    core.authenticationKeys - <code>assertionMethod</code> → derived
    from core.assertionKeys - <code>updatePolicy</code> →
    core.updatePolicy - <code>capabilityInvocation</code> → derived from
    the appropriate core keys - <code>keyAgreement</code> → derived from
    core.keyAgreementKeys - <code>service</code> → derived from
    core.services. If the core has no services, the service property
    MUST be omitted from the DID Document. - <code>keyHistory</code> →
    ordered list of prior core CIDs</p>
    <p>These fields MUST reflect the core exactly, and MUST NOT
    introduce information not present in the core snapshot.</p>
    <h3 id="method-specific-extensions-non-core-metadata">9.2
    Method-Specific Extensions (Non-Core Metadata)</h3>
    <p>The DID Document MAY include additional non-authoritative
    metadata that does not affect the core state: -
    <code>attestations</code> — signatures over the core object -
    <code>proof</code> — optional Data Integrity Proof (P-256) over
    currentCore - <code>domainVerification</code> — optional DNS/HTTP
    domain-binding - any other optional terms defined in the JSON-LD
    context at: https://did-me.org/ns/did-me/v1</p>
    <p>Processors that do not recognize these fields MUST ignore them,
    per DID Core rules. When projecting from core to DID Document JSON,
    <code>prev</code> MUST be omitted when <code>core.prev</code> is
    null (genesis state) and MUST be present as a non-null CID value
    when <code>sequence &gt; 1</code>. <code>proof</code> remains
    optional metadata in v1; however, profiles that require ZK anchoring
    SHOULD include it.</p>
    <h4 id="domain-verification-objects">9.3 Domain Verification
    Objects</h4>
    <p>Each optional domainVerification entry MUST include:</p>
    <ul>
    <li><strong>type</strong> (string) — the verification object type
    (“DnsTxtVerification” or “HttpsWellKnownVerification”)</li>
    <li><strong>domain</strong> (string)</li>
    <li><strong>method</strong> (string)</li>
    <li><strong>binding</strong> or <strong>proofUrl</strong> (depending
    on method)</li>
    </ul>
    <p>Resolvers MUST accept at least one valid domain-verification
    method. Support for both is RECOMMENDED.</p>
    <h3 id="requirements">9.4 Requirements</h3>
    <ul>
    <li>Reconstructing DID state MUST be possible using only the core
    snapshot and its signatures.</li>
    <li>The DID Document MUST NOT override or conflict with the contents
    of the signed core.</li>
    <li>Optional fields MUST NOT influence update authorization or core
    validity.</li>
    <li>The resolver MUST treat any mismatch between the core and
    projection as an error.</li>
    <li>If <code>coreCbor</code> is present, decoding it MUST produce
    canonical DAG-CBOR bytes whose CID equals
    <code>currentCore</code>.</li>
    <li>In the did:me v1 default profile (Section 14),
    <code>coreCbor</code> is required to enable self-contained
    attestation verification.</li>
    </ul>
    <hr />
    <h2 id="json-ld-context">10. JSON-LD Context</h2>
    <p><code>did:me JSON-LD</code> context provides optional metadata
    extensions. Implementations MUST ignore any unrecognized terms,
    consistent with DID Core processing rules.</p>
    <p>The did:me JSON-LD context is published at
    https://did-me.org/ns/did-me/v1.</p>
    <p>This context defines: - method-specific terms (sequence, prev,
    currentCore, coreCbor, keyHistory) - metadata terms (updatePolicy,
    attestations, domainVerification) - service types (e.g.,
    ReallyMeDirectoryService) - optional device- or persona-related
    extensions (e.g., hardwareBound, biometricProtected,
    deviceModel)</p>
    <p>All terms defined in the context: - MAY appear in DID Documents -
    MUST NOT influence the authoritative core state unless explicitly
    part of the core schema - MUST be ignored by processors that do not
    understand them, per DID Core rules</p>
    <p>The JSON-LD context MUST be included in all did:me DID Documents
    to guarantee consistent interpretation of method-specific terms. The
    first three <code>@context</code> entries MUST be the canonical
    did:me context tuple, in this exact order: 1.
    <code>https://www.w3.org/ns/did/v1</code> 2.
    <code>https://w3id.org/security/multikey/v1</code> 3.
    <code>https://did-me.org/ns/did-me/v1</code> Additional contexts MAY
    follow and MUST NOT redefine terms from the canonical tuple.
    Conformance checkers and validators SHOULD reject DID Documents
    whose additional contexts redefine terms from the canonical
    tuple.</p>
    <h4 id="alsoknownas-optional-correlation-identifiers">10.1
    alsoKnownAs (Optional Correlation Identifiers)</h4>
    <p><code>alsoKnownAs</code> is an optional DID Core property that
    MAY appear in a did:me DID Document. It provides human-readable or
    system-assigned alternate identifiers, such as short profile URLs,
    usernames, handles, or legacy identifiers. These values: • do not
    participate in update authorization • do not affect core validity •
    do not alter the canonical core snapshot • MAY be ignored by
    resolvers or relying parties</p>
    <pre><code>
  &quot;alsoKnownAs&quot;: [
  &quot;https://domain/&lt;short-id&gt;&quot;
]</code></pre>
    <p>alsoKnownAs is strictly non-authoritative metadata and serves
    only as an optional correlation convenience.</p>
    <h4 id="hardware-bound-and-biometric-protected">10.2 Hardware Bound
    and Biometric Protected</h4>
    <p><code>hardwareBound</code> and <code>biometricProtected</code>
    are optional metadata fields that describe protection
    characteristics of the controller’s authentication environment.
    These fields are not authoritative, do not affect core state, and
    MAY be ignored by relying parties.</p>
    <h4 id="user-verification-method">10.3 User Verification Method</h4>
    <p><code>userVerificationMethod</code> is optional metadata
    describing how a user authenticates locally (face, fingerprint, pin,
    passcode, password, iris, voice, pattern, none). This field is
    non-authoritative and MUST NOT influence the validity of a core
    snapshot.</p>
    <h4 id="device-and-model">10.4 Device and Model</h4>
    <p><code>deviceModel</code> is optional metadata identifying the
    user’s device model or hardware platform. It is purely informational
    and does not affect DID state.</p>
    <hr />
    <h2 id="security-considerations">11. Security Considerations</h2>
    <ul>
    <li><strong>Rollback protection</strong>: enforced through monotonic
    sequence values</li>
    <li><strong>Fork prevention</strong>: enforced through prev linking
    the previous core snapshot</li>
    <li><strong>Tamper-evidence</strong>: achieved via CIDv1 (SHA-256,
    DAG-CBOR) and core signatures</li>
    <li><strong>Authorized updates</strong>: restricted to verification
    methods listed in updatePolicy</li>
    <li><strong>Canonical encoding</strong>: core signatures MUST cover
    the canonical DAG-CBOR bytes</li>
    <li><strong>Projection safety</strong>: DID Documents are
    non-authoritative projections; validators must rely on core +
    signatures</li>
    <li><strong>Key rotation</strong>: does not change the DID; state
    changes only via new core snapshots</li>
    <li><strong>Backup practices</strong>: operators SHOULD maintain
    redundant storage of core snapshots and DID Documents</li>
    <li><strong>Cryptographic agility</strong>: coexistence of classical
    (Ed25519, ES256) and post-quantum (ML-DSA-87, ML-KEM-768,
    ML-KEM-1024) suites ensures long-term security</li>
    <li><strong>ECDSA S-Value Forms</strong>: ES256 signatures may use
    either low-S or high-S encoding. Both forms are secure and
    mathematically equivalent. Verifiers MUST accept both and MAY
    normalize signatures to low-S form internally for canonicality.</li>
    </ul>
    <hr />
    <h2 id="decentralization-and-federation">12. Decentralization and
    Federation</h2>
    <p>did:me identifiers are fundamentally self-hosted and do not rely
    on any central registry. Optional public directories may mirror
    published DID Documents for discovery. The method’s structure
    supports decentralized and federated deployments without breaking
    existing identifiers.</p>
    <p>The method supports: - <strong>Multi-directory
    federation</strong> – multiple independent operators may host
    equivalent projections of the same DID state for discovery. -
    <strong>Verifiable replay</strong> – any resolver can reconstruct
    canonical DID state by validating the chain of signed core
    snapshots. - <strong>Independent resolution</strong> – resolvers do
    not need to trust any directory, host, or service; all validation
    derives from the signed core chain.</p>
    <p>This is enabled by: - <code>sequence</code> – enforces strict
    update ordering<br />
    - <code>prev</code> – links each core snapshot to the previous
    CID<br />
    - <code>currentCore</code> – cryptographic addressing of core
    snapshots<br />
    - signed canonical cores – guarantee tamper-evident integrity</p>
    <p>These features allow did:me to evolve toward decentralized,
    distributed, or mirrored resolution models in the future.</p>
    <hr />
    <h2 id="illustrative-didme-json-member-order-non-normative">13.
    Illustrative did:me JSON member order (non-normative)</h2>
    <p>JSON member order is non-normative. Producers MAY emit members in
    any order, and processors MUST NOT rely on JSON key order for
    validity. <sub></sub>~ <span class="citation" data-cites="context">@context</span> id controller alsoKnownAs
    sequence prev</p>
    <p>hardwareBound biometricProtected userVerificationMethod
    deviceModel</p>
    <p>coreCbor currentCore keyHistory</p>
    <p>verificationMethod authentication assertionMethod
    capabilityInvocation keyAgreement</p>
    <p>service(s) updatePolicy attestations proof <sub></sub>~</p>
    <h2 id="default-profile-requirements-matrix-didme-v1">14. Default
    Profile Requirements Matrix (did:me v1)</h2>
    <p>This section is normative for the did:me v1 default
    interoperability profile. The base method model is defined in
    Sections 5 through 9; this profile adds stricter required key sets
    and relationship requirements for public did:me v1 deployments.</p>
    <p>This table defines for every DID Document field:</p>
    <ul>
    <li><strong>Required?</strong>: MUST appear for a valid did:me v1
    default-profile DID Document<br />
    </li>
    <li><strong>Nullable?</strong>: Whether the field may be
    <code>null</code><br />
    </li>
    <li><strong>Emit When Empty?</strong>: Whether to include the JSON
    key when the value is empty<br />
    </li>
    <li><strong>Notes</strong>: Method-specific behavior</li>
    </ul>
    <h3 id="did-document-field-matrix">14.1 DID Document Field
    Matrix</h3>
    <table>
    <colgroup>
    <col style="width: 12%" />
    <col style="width: 20%" />
    <col style="width: 20%" />
    <col style="width: 34%" />
    <col style="width: 12%" />
    </colgroup>
    <thead>
    <tr>
    <th>Field</th>
    <th>Required</th>
    <th>Nullable</th>
    <th>Emit When Empty</th>
    <th>Notes</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><span class="citation" data-cites="context">@context</span></td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>The first 3 entries MUST be, in order:
    <code>https://www.w3.org/ns/did/v1</code>,
    <code>https://w3id.org/security/multikey/v1</code>,
    <code>https://did-me.org/ns/did-me/v1</code>. Additional contexts
    MAY follow and MUST NOT redefine terms from the canonical
    tuple.</td>
    </tr>
    <tr>
    <td>id</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST be a valid <code>did:me:</code> identifier.</td>
    </tr>
    <tr>
    <td>controller</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST be either: (a) a <code>did:me:</code> string, or (b) a
    non-empty array of <code>did:me:</code> strings.</td>
    </tr>
    <tr>
    <td>alsoKnownAs</td>
    <td>No</td>
    <td>No</td>
    <td>Omit if empty</td>
    <td>Optional. MUST be an array when present.</td>
    </tr>
    <tr>
    <td>sequence</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST equal <code>keyHistory.count + 1</code>.</td>
    </tr>
    <tr>
    <td>prev</td>
    <td>Conditional</td>
    <td>No</td>
    <td>Omit when sequence=1</td>
    <td>MUST be omitted when sequence=1; otherwise MUST equal last
    keyHistory entry.</td>
    </tr>
    <tr>
    <td>hardwareBound</td>
    <td>No</td>
    <td>Yes</td>
    <td>Omit if null/false</td>
    <td>Optional metadata. False treated as absent.</td>
    </tr>
    <tr>
    <td>biometricProtected</td>
    <td>No</td>
    <td>Yes</td>
    <td>Omit if null/false</td>
    <td>Optional metadata. False treated as absent.</td>
    </tr>
    <tr>
    <td>userVerificationMethod</td>
    <td>No</td>
    <td>Yes</td>
    <td>Omit if null</td>
    <td>Optional (“face”, “pin”, etc.).</td>
    </tr>
    <tr>
    <td>deviceModel</td>
    <td>No</td>
    <td>Yes</td>
    <td>Omit if null/empty</td>
    <td>Optional metadata.</td>
    </tr>
    <tr>
    <td>coreCbor</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>Base64url-encoded canonical DAG-CBOR bytes of the current core
    snapshot; decoded bytes MUST hash to <code>currentCore</code>.</td>
    </tr>
    <tr>
    <td>currentCore</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST be CIDv1 of the core snapshot.</td>
    </tr>
    <tr>
    <td>keyHistory</td>
    <td>Yes</td>
    <td>No</td>
    <td><strong>Emit empty array</strong></td>
    <td>MUST contain only past CIDs; MUST NOT include currentCore.</td>
    </tr>
    <tr>
    <td>verificationMethod</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST contain all required key types.</td>
    </tr>
    <tr>
    <td>authentication</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST contain at least <code>#ed25519</code> and
    <code>#mldsa87-auth</code>.</td>
    </tr>
    <tr>
    <td>assertionMethod</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST include <code>#p256</code>.</td>
    </tr>
    <tr>
    <td>capabilityInvocation</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST include <code>#mldsa87-root</code>.</td>
    </tr>
    <tr>
    <td>keyAgreement</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST include <code>#x25519</code> and at least one of
    <code>#mlkem768</code> or <code>#mlkem1024</code>.</td>
    </tr>
    <tr>
    <td>service</td>
    <td>No</td>
    <td>No</td>
    <td>Omit if empty</td>
    <td>Include only when one or more services exist.</td>
    </tr>
    <tr>
    <td>updatePolicy</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST include allowedVerificationMethods containing
    <code>#mldsa87-root</code>.</td>
    </tr>
    <tr>
    <td>attestations</td>
    <td>Yes</td>
    <td>No</td>
    <td>N/A</td>
    <td>MUST have ≥1 ML-DSA-87 core signature.</td>
    </tr>
    <tr>
    <td>proof</td>
    <td>No</td>
    <td>No</td>
    <td>Omit if absent</td>
    <td>Optional in v1; strongly recommended for profiles requiring ZK
    anchoring.</td>
    </tr>
    <tr>
    <td>domainVerification</td>
    <td>No</td>
    <td>No</td>
    <td>Omit if empty</td>
    <td>Optional DNS/HTTP domain-bindings.</td>
    </tr>
    </tbody>
    </table>
    <h3 id="null-vs-omission-rules-summary">14.2 Null vs Omission Rules
    Summary</h3>
    <p>NEVER emit explicit <code>null</code> in the JSON DID
    Document.</p>
    <ul>
    <li>Optional fields MUST be omitted entirely when not present.</li>
    <li>Arrays MUST either contain values or be omitted (except
    <code>keyHistory</code>, which MUST be an empty array when no
    entries exist).</li>
    <li>Optional booleans (<code>hardwareBound</code>,
    <code>biometricProtected</code>) SHOULD be omitted when false unless
    explicitly set.</li>
    </ul>
    <h3 id="required-arrays-non-null">14.3 Required Arrays
    (non-null)</h3>
    <p>These MUST always be present in the JSON and MUST NOT be
    null:</p>
    <ul>
    <li>verificationMethod<br />
    </li>
    <li>authentication<br />
    </li>
    <li>assertionMethod<br />
    </li>
    <li>capabilityInvocation<br />
    </li>
    <li>keyAgreement<br />
    </li>
    <li>attestations<br />
    </li>
    <li>keyHistory (may be empty but MUST be present)</li>
    </ul>
    <h3 id="optional-arrays">14.4 Optional Arrays</h3>
    <p>These MAY be omitted entirely:</p>
    <ul>
    <li>alsoKnownAs<br />
    </li>
    <li>service<br />
    </li>
    <li>domainVerification</li>
    </ul>
    <pre><code>{
  &quot;domainVerification&quot;: [
    {
      &quot;method&quot;: &quot;dns&quot;,
      &quot;domain&quot;: &quot;example.com&quot;,
      &quot;dns&quot;: {
        &quot;recordName&quot;: &quot;_did&quot;,
        &quot;txtValue&quot;: &quot;did=me:123...&quot;
      }
    }
  ]
}</code></pre>
    <p>or</p>
    <pre><code>{
  &quot;domainVerification&quot;: [
    {
      &quot;method&quot;: &quot;wellknown&quot;,
      &quot;domain&quot;: &quot;example.com&quot;,
      &quot;wellknown&quot;: {
        &quot;uri&quot;: &quot;/.well-known/did-configuration.json&quot;,
        &quot;content&quot;: &quot;eyAidHlwZSI6ICJkaWQtY29uZmlnIiB9&quot; 
      }
    }
  ]
}</code></pre>
    <p>domainVerification entries are self-asserted claims added by the
    DID controller. Resolvers and relying parties MUST NOT assume these
    claims are accurate. Independent verification MUST be performed by
    the verifier.</p>
    <h2 id="did-document-relationship-definitions">DID Document
    Relationship Definitions</h2>
    <h3 id="verificationmethod">verificationMethod</h3>
    <p><strong>Definition:</strong><br />
    A list of all public keys the DID controls.</p>
    <p><strong>Meaning:</strong><br />
    These keys exist and can be referenced by other DID Document
    sections.<br />
    This list does <em>not</em> define how the keys are used; roles
    appear below.</p>
    <p><strong>Used for:</strong><br />
    - Declaring available keys<br />
    - Referencing keys in authentication, assertionMethod, etc.<br />
    - Interoperability with DID Core processors</p>
    <hr />
    <h3 id="authentication">authentication</h3>
    <p><strong>Definition:</strong><br />
    Keys used to prove control of the DID in interactive protocols.</p>
    <p><strong>Used for:</strong><br />
    - Logging in<br />
    - Pairwise authentication<br />
    - Messaging identity proofs<br />
    - Presentations that require DID control verification</p>
    <p><strong>Key types:</strong><br />
    - Ed25519<br />
    - ML-DSA-87<br />
    - P-256<br />
    (Never X25519 or ML-KEM; they cannot sign.)</p>
    <hr />
    <h3 id="assertionmethod">assertionMethod</h3>
    <p><strong>Definition:</strong><br />
    Keys used to sign statements <em>made by the DID</em>, including
    VCs, public claims, and ZK-friendly proofs.</p>
    <p><strong>Used for:</strong><br />
    - Verifiable Credential issuance<br />
    - Identity claims<br />
    - Public profile statements<br />
    - ZK-friendly attestations (P-256)</p>
    <p><strong>Key types:</strong><br />
    - Ed25519<br />
    - ML-DSA-87<br />
    - P-256<br />
    (Never X25519 or ML-KEM.)</p>
    <hr />
    <h3 id="keyagreement">keyAgreement</h3>
    <p><strong>Definition:</strong><br />
    Keys used to derive shared secrets for encrypted channels.</p>
    <p><strong>Used for:</strong><br />
    - Secure messaging<br />
    - Encrypted VC presentation<br />
    - Session establishment<br />
    - Hybrid encryption (X25519 + ML-KEM-768 + ML-KEM-1024)</p>
    <p><strong>Key types:</strong><br />
    - X25519<br />
    - ML-KEM-768<br />
    - ML-KEM-1024<br />
    (Never Ed25519 or P-256; those are signing keys.)</p>
    <hr />
    <h3 id="capabilityinvocation">capabilityInvocation</h3>
    <p><strong>Definition:</strong><br />
    Keys authorized to change or update DID state. These are the
    <strong>root control keys</strong>.</p>
    <p><strong>Used for:</strong><br />
    - DID Document updates<br />
    - Key rotation<br />
    - Recovery operations<br />
    - Deactivation</p>
    <p><strong>Key types:</strong><br />
    - ML-DSA-87 (recommended primary root)<br />
    - Ed25519 (optional second root for hybrid AND-control)<br />
    (Never X25519 or ML-KEM. P-256 should only be used if Secure Enclave
    must sign updates.)</p>
    <hr />
    <h3 id="attestations">attestations</h3>
    <p><strong>Definition:</strong><br />
    Signatures over the canonical core snapshot (DAG-CBOR) that validate
    DID state.<br />
    Used for hybrid AND-security.</p>
    <p><strong>Used for:</strong><br />
    - Proving core snapshot authenticity<br />
    - True hybrid root control (Ed25519 AND ML-DSA-87)<br />
    - Long-term survivability across cryptographic eras</p>
    <p><strong>Key types:</strong><br />
    - Ed25519<br />
    - ML-DSA-87</p>
    <hr />
    <h3 id="proof">proof</h3>
    <p><strong>Definition:</strong><br />
    A <em>non-authoritative</em> P-256 Data Integrity Proof for
    compatibility with ZK systems, Apple Secp256r1 flows, and DI
    verifiers.</p>
    <p><strong>Used for:</strong><br />
    - ZK proof integrations<br />
    - Apple Secure Enclave-backed identities<br />
    - EUDI Wallet compatibility<br />
    - JWS-based verifiers</p>
    <p><strong>Key types:</strong><br />
    - P-256 only<br />
    (Does not control DID updates.)</p>
    <table>
    <colgroup>
    <col style="width: 6%" />
    <col style="width: 14%" />
    <col style="width: 14%" />
    <col style="width: 20%" />
    <col style="width: 11%" />
    <col style="width: 16%" />
    <col style="width: 15%" />
    </colgroup>
    <thead>
    <tr>
    <th>DID Type</th>
    <th>Authentication</th>
    <th>Assertion / Proofs</th>
    <th>Verification Methods (VM Set)</th>
    <th>Key Agreement</th>
    <th>Capability Invocation (Root Control)</th>
    <th>Attestations (Core Update)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><strong>Core Identity</strong> (private wallet, root
    identity)</td>
    <td>Ed25519 + ML-DSA-87 + P-256</td>
    <td>ML-DSA-87 + Ed25519 + P-256 (ZK-friendly)</td>
    <td>Ed25519, ML-DSA-87, P-256, X25519, ML-KEM-768, ML-KEM-1024</td>
    <td>X25519 + ML-KEM-768 and/or ML-KEM-1024</td>
    <td><strong>ML-DSA-87 AND Ed25519</strong> (dual required)</td>
    <td><strong>Required dual</strong> (ML-DSA + Ed25519)</td>
    </tr>
    <tr>
    <td><strong>Public Profile</strong> (persona; receives ZK
    proofs)</td>
    <td>Ed25519 + P-256 (+ optional ML-DSA-87)</td>
    <td>Ed25519 + P-256 (+ optional ML-DSA-87)</td>
    <td>Ed25519, ML-DSA-87, P-256, X25519, ML-KEM-768, ML-KEM-1024</td>
    <td>X25519 + ML-KEM-768 and/or ML-KEM-1024</td>
    <td><strong>ML-DSA-87 only</strong></td>
    <td>Optional (P-256 DI proof recommended)</td>
    </tr>
    <tr>
    <td><strong>Public Profile + Issuer</strong> (VC issuer
    persona)</td>
    <td>Ed25519 + ML-DSA-87 + P-256</td>
    <td>ML-DSA-87 (primary) + Ed25519 + P-256</td>
    <td>Ed25519, ML-DSA-87, P-256, X25519, ML-KEM-768, ML-KEM-1024</td>
    <td>X25519 + ML-KEM-768 and/or ML-KEM-1024</td>
    <td><strong>ML-DSA-87 AND Ed25519</strong></td>
    <td>Optional dual or PQ-only</td>
    </tr>
    <tr>
    <td><strong>Issuer DID</strong> (Harvard, banks, orgs)</td>
    <td>Ed25519 + ML-DSA-87 + P-256</td>
    <td>ML-DSA-87 (primary) + Ed25519 + P-256</td>
    <td>Ed25519, ML-DSA-87, P-256</td>
    <td>Optional</td>
    <td><strong>ML-DSA-87 AND Ed25519</strong></td>
    <td>Optional dual or PQ-only</td>
    </tr>
    <tr>
    <td><strong>Messaging DID</strong> (fast, throwaway,
    persona-tied)</td>
    <td>Ed25519 (+ optional P-256)</td>
    <td>None or P-256 if ZK required</td>
    <td>Ed25519, P-256, X25519, ML-KEM-768, ML-KEM-1024</td>
    <td>X25519 + ML-KEM-768 and/or ML-KEM-1024</td>
    <td>Ed25519</td>
    <td>None</td>
    </tr>
    <tr>
    <td><strong>Payment / Wallet DID</strong> (optional
    specialization)</td>
    <td>secp256k1 + optional P-256</td>
    <td>Optional</td>
    <td>secp256k1, P-256</td>
    <td>Rare</td>
    <td>secp256k1</td>
    <td>Optional</td>
    </tr>
    </tbody>
    </table>
    <hr />
    <h2 id="conformance-test-vectors-informative">15. Conformance Test
    Vectors (Informative)</h2>
    <p>This section provides implementation-oriented conformance
    vectors. It is informative and does not replace normative
    requirements in Sections 5 through 14.</p>
    <h3 id="context-canonical-prefix">15.1 <span class="citation" data-cites="context">@context</span> Canonical Prefix</h3>
    <h4 id="valid">15.1.1 Valid</h4>
    <p>The first three <code>@context</code> entries match the canonical
    tuple in order:</p>
    <pre><code>&quot;@context&quot;: [
  &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;https://w3id.org/security/multikey/v1&quot;,
  &quot;https://did-me.org/ns/did-me/v1&quot;,
  &quot;https://example.org/extra-context&quot;
]</code></pre>
    <p>Expected result: <strong>ACCEPT</strong></p>
    <h4 id="invalid">15.1.2 Invalid</h4>
    <p>Wrong order in first three entries:</p>
    <pre><code>&quot;@context&quot;: [
  &quot;https://w3id.org/security/multikey/v1&quot;,
  &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;https://did-me.org/ns/did-me/v1&quot;
]</code></pre>
    <p>Expected result: <strong>REJECT</strong></p>
    <h4 id="invalid-term-redefinition-in-additional-context">15.1.3
    Invalid (Term Redefinition in Additional Context)</h4>
    <p>Additional context attempts to redefine a canonical term:</p>
    <pre><code>&quot;@context&quot;: [
  &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;https://w3id.org/security/multikey/v1&quot;,
  &quot;https://did-me.org/ns/did-me/v1&quot;,
  {
    &quot;currentCore&quot;: &quot;https://example.org/redefinedCurrentCore&quot;
  }
]</code></pre>
    <p>Expected result: <strong>REJECT</strong></p>
    <h3 id="corecbor-and-currentcore-consistency">15.2
    <code>coreCbor</code> and <code>currentCore</code> Consistency</h3>
    <h4 id="valid-1">15.2.1 Valid</h4>
    <ul>
    <li><code>coreCbor</code> decodes as canonical DAG-CBOR core
    bytes</li>
    <li>CID(core bytes) equals <code>currentCore</code></li>
    </ul>
    <p>Expected result: <strong>ACCEPT</strong></p>
    <h4 id="invalid-1">15.2.2 Invalid</h4>
    <ul>
    <li><code>coreCbor</code> decodes, but CID(core bytes) does not
    equal <code>currentCore</code></li>
    </ul>
    <p>Expected result: <strong>REJECT</strong></p>
    <h3 id="sequence-prev-and-keyhistory">15.3 <code>sequence</code>,
    <code>prev</code>, and <code>keyHistory</code></h3>
    <h4 id="valid-genesis">15.3.1 Valid Genesis</h4>
    <pre><code>&quot;sequence&quot;: 1,
&quot;keyHistory&quot;: []</code></pre>
    <p><code>prev</code> is omitted in the DID Document projection for
    genesis.</p>
    <p>Expected result: <strong>ACCEPT</strong></p>
    <h4 id="invalid-non-genesis">15.3.2 Invalid Non-Genesis</h4>
    <pre><code>&quot;sequence&quot;: 3,
&quot;keyHistory&quot;: [&quot;cidA&quot;, &quot;cidB&quot;],
&quot;prev&quot;: &quot;cidA&quot;</code></pre>
    <p>Expected result: <strong>REJECT</strong> (<code>prev</code> MUST
    equal last <code>keyHistory</code> entry for
    <code>sequence &gt; 1</code>)</p>
    <h3 id="core-attestation-validation">15.4 Core Attestation
    Validation</h3>
    <h4 id="valid-2">15.4.1 Valid</h4>
    <pre><code>&quot;attestations&quot;: [
  {
    &quot;alg&quot;: &quot;ML-DSA-87&quot;,
    &quot;vm&quot;: &quot;#mldsa87-root&quot;,
    &quot;sig&quot;: &quot;&lt;valid-base64url-signature-over-coreCbor-bytes&gt;&quot;
  }
]</code></pre>
    <p>Expected result: <strong>ACCEPT</strong> when: - <code>vm</code>
    exists in <code>verificationMethod</code> - <code>alg</code> matches
    verification method algorithm - decoded <code>sig</code> verifies
    over decoded <code>coreCbor</code> bytes</p>
    <h4 id="invalid-2">15.4.2 Invalid</h4>
    <pre><code>&quot;attestations&quot;: [
  {
    &quot;alg&quot;: &quot;ML-DSA-87&quot;,
    &quot;vm&quot;: &quot;#mldsa87-root&quot;,
    &quot;sig&quot;: &quot;!!!not-base64url!!!&quot;
  }
]</code></pre>
    <p>Expected result: <strong>REJECT</strong></p>
    <h3 id="data-integrity-proof-behavior">15.5 Data Integrity Proof
    Behavior</h3>
    <h4 id="valid-supported-suite">15.5.1 Valid (Supported Suite)</h4>
    <pre><code>&quot;proof&quot;: {
  &quot;type&quot;: &quot;DataIntegrityProof&quot;,
  &quot;cryptosuite&quot;: &quot;es256-jws-cid-2025&quot;,
  &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
  &quot;verificationMethod&quot;: &quot;#p256&quot;,
  &quot;created&quot;: &quot;2026-01-01T00:00:00Z&quot;,
  &quot;jws&quot;: &quot;&lt;valid-compact-jws&gt;&quot;
}</code></pre>
    <p>Expected result: - <strong>ACCEPT</strong> only if all
    cryptosuite checks pass, including: - <code>type</code> is
    <code>DataIntegrityProof</code> - <code>cryptosuite</code> is
    <code>es256-jws-cid-2025</code> - protected JWS header is exactly
    <code>{&quot;alg&quot;:&quot;ES256&quot;}</code> - payload equals
    <code>currentCore</code> - ES256 signature verifies with the
    referenced P-256 verification method - proof remains
    non-authoritative for update validity</p>
    <h4 id="unsupported-suite-handling">15.5.2 Unsupported Suite
    Handling</h4>
    <pre><code>&quot;proof&quot;: {
  &quot;type&quot;: &quot;DataIntegrityProof&quot;,
  &quot;cryptosuite&quot;: &quot;unsupported-suite&quot;,
  &quot;jws&quot;: &quot;header.payload.signature&quot;
}</code></pre>
    <p>Expected result: - proof treated as <strong>unsupported</strong>
    - proof MUST NOT be treated as valid - core-based DID validity
    processing continues</p>
  </main>

</div>

<script>
  // Mobile toggle
  const btn = document.getElementById('menuButton');
  const sidebar = document.getElementById('sidebar');
  btn.addEventListener('click', () => {
    sidebar.classList.toggle('open');
  });
</script>

</body>
</html>
